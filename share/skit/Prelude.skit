!id \x.x
!false \x.\y.y
!true \x.\y.x
!if \c.\t.\f.c t f
!Y S S I (C B (S I I))
!flip \f.\x.\y.f y x
!succ + 1
!pred flip - 1
!not \x.if x false true
!and \x.\y.if x y false
!or \x.\y.if x true y
!lt \x.\y.and (le x y) (not (eq x y))
!gt \x.\y.not (le x y)
!ge \x.\y.not (lt x y)
!ne \x.\y.not (eq x y)
!zero \x.eq x 0 true false
!count Y (\f.\n.zero n 0 (f (- n 1)))
!fac Y (\f.\n.zero n 1 (* n (f (- n 1))))
!gcd Y (\f.\a.\b.if (zero b) a (f b (mod a b)))
!rec Y (\f.\x.eq x 0 22 (f (pred x)))
!str \x.\y.y 66 (\x.\y.y 67 (\x.\y.x))
!head \v.v K (\x.\y.x)
!tail \v.v K (\x.\y.y)
!cons \x.\y.\a.\b.b x y
!nil \a.\b.a
!null \x.x true (\x.\y.false)
!map Y (\m.\f.\list.null list nil (cons (f (head list)) (m f (tail list))))
!foldr Y (\foldr.\f.\z.\xs.null xs z (f (head xs) (foldr f z (tail xs))))
!sum foldr + 0
!fromTo Y (\fromTo.\lo.\hi.gt lo hi nil (cons lo (fromTo (succ lo) hi)))